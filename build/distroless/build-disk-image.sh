#!/bin/bash
# Build a bootable disk image for distroless using bootc install to-filesystem
# This script handles partition setup and bootloader installation manually
# since bootc install to-disk requires bootupd which GNOME OS doesn't have.
#
# Based on Dakota's install-to-disk.just approach.
#
# Usage: ./build-disk-image.sh <image-file> <container-image> [filesystem]
#
# Example:
#   ./build-disk-image.sh ./bootable.img quay.io/immutablue/immutablue:43-distroless btrfs

set -euo pipefail

IMAGE_FILE="${1:?Usage: $0 <image-file> <container-image> [filesystem]}"
CONTAINER_IMAGE="${2:?Usage: $0 <image-file> <container-image> [filesystem]}"
FILESYSTEM="${3:-btrfs}"
IMAGE_SIZE="${IMAGE_SIZE:-50G}"
MOUNT_POINT="/var/mnt/distroless-install"

echo "=== Distroless Disk Image Builder ==="
echo "Image file: ${IMAGE_FILE}"
echo "Container: ${CONTAINER_IMAGE}"
echo "Filesystem: ${FILESYSTEM}"
echo "Size: ${IMAGE_SIZE}"
echo ""

# Create image file if needed
if [[ ! -f "${IMAGE_FILE}" ]]; then
    echo "Creating ${IMAGE_SIZE} image file..."
    fallocate -l "${IMAGE_SIZE}" "${IMAGE_FILE}"
fi

# Setup loopback device
echo "Setting up loopback device..."
LOOP_DEV=$(sudo losetup --find --show --partscan "${IMAGE_FILE}")
echo "Using loop device: ${LOOP_DEV}"

cleanup() {
    echo "Cleaning up..."
    sudo umount -R "${MOUNT_POINT}" 2>/dev/null || true
    sudo losetup -d "${LOOP_DEV}" 2>/dev/null || true
    sudo rm -rf "${MOUNT_POINT}" 2>/dev/null || true
}
trap cleanup EXIT

# Partition the disk
# - Part 1: 1MB BIOS boot (for legacy BIOS)
# - Part 2: 512MB EFI System Partition
# - Part 3: Rest for root filesystem
echo "Partitioning disk..."
sudo sgdisk -Z "${LOOP_DEV}"
sudo sgdisk -n 1:0:+1M -t 1:ef02 -c 1:"BIOS" "${LOOP_DEV}"
sudo sgdisk -n 2:0:+512M -t 2:ef00 -c 2:"EFI" "${LOOP_DEV}"
sudo sgdisk -n 3:0:0 -t 3:8304 -c 3:"ROOT" "${LOOP_DEV}"

# Refresh partition table
sudo partprobe "${LOOP_DEV}"
sleep 1

# Determine partition device names
if [[ "${LOOP_DEV}" =~ "loop" ]]; then
    PART_EFI="${LOOP_DEV}p2"
    PART_ROOT="${LOOP_DEV}p3"
else
    PART_EFI="${LOOP_DEV}2"
    PART_ROOT="${LOOP_DEV}3"
fi

echo "EFI partition: ${PART_EFI}"
echo "Root partition: ${PART_ROOT}"

# Format partitions
echo "Formatting EFI partition..."
sudo mkfs.fat -F 32 -n EFI "${PART_EFI}"

echo "Formatting root partition as ${FILESYSTEM}..."
case "${FILESYSTEM}" in
    btrfs)
        sudo mkfs.btrfs -f -L ROOT "${PART_ROOT}"
        ;;
    ext4)
        sudo mkfs.ext4 -L ROOT "${PART_ROOT}"
        ;;
    xfs)
        sudo mkfs.xfs -f -L ROOT "${PART_ROOT}"
        ;;
    *)
        echo "Unsupported filesystem: ${FILESYSTEM}"
        exit 1
        ;;
esac

# Mount filesystems
echo "Mounting filesystems..."
sudo mkdir -p "${MOUNT_POINT}"
sudo mount "${PART_ROOT}" "${MOUNT_POINT}"
sudo mkdir -p "${MOUNT_POINT}/boot/efi"
sudo mount "${PART_EFI}" "${MOUNT_POINT}/boot/efi"

# Get UUIDs for fstab
ROOT_UUID=$(sudo blkid -s UUID -o value "${PART_ROOT}")
EFI_UUID=$(sudo blkid -s UUID -o value "${PART_EFI}")

echo "Root UUID: ${ROOT_UUID}"
echo "EFI UUID: ${EFI_UUID}"

# Run bootc install to-filesystem
echo "Running bootc install to-filesystem..."
sudo podman run \
    --rm --privileged --pid=host \
    -it \
    -v /var/lib/containers:/var/lib/containers \
    -v /dev:/dev \
    -v "${MOUNT_POINT}:${MOUNT_POINT}" \
    --security-opt label=type:unconfined_t \
    -e RUST_LOG=debug \
    "${CONTAINER_IMAGE}" bootc install to-filesystem "${MOUNT_POINT}" \
        --composefs-backend \
        --bootloader systemd \
        --skip-finalize \
        --karg systemd.firstboot=no \
        --karg splash \
        --karg quiet

# Create fstab (before we finalize)
echo "Creating fstab..."
# composefs backend uses /state/deploy instead of /ostree/deploy
DEPLOY_DIR=$(sudo find "${MOUNT_POINT}/state/deploy" -maxdepth 1 -type d ! -path "${MOUNT_POINT}/state/deploy" 2>/dev/null | head -n1)

if [[ -n "${DEPLOY_DIR}" ]]; then
    echo "Found deploy dir: ${DEPLOY_DIR}"
    COMPOSEFS_HASH=$(basename "${DEPLOY_DIR}")

    # Create fstab in the deploy directory
    sudo bash -c "cat > ${DEPLOY_DIR}/etc/fstab << EOF
# /etc/fstab - Generated by distroless build script
UUID=${ROOT_UUID}  /      ${FILESYSTEM}  defaults  0 0
UUID=${EFI_UUID}   /boot  vfat   defaults  0 2
EOF"
    echo "fstab created at ${DEPLOY_DIR}/etc/fstab"

    # Update boot entry with correct root and composefs hash
    BOOT_ENTRY=$(ls -d "${MOUNT_POINT}"/boot/efi/loader/entries/*.conf 2>/dev/null | head -n1)
    if [[ -n "${BOOT_ENTRY}" ]]; then
        echo "Updating boot entry: ${BOOT_ENTRY}"
        sudo sed -i \
            "s|^options.*|options root=UUID=${ROOT_UUID} rootflags=subvol=/ rw boot=UUID=${EFI_UUID} composefs=${COMPOSEFS_HASH} systemd.firstboot=no splash quiet|" \
            "${BOOT_ENTRY}"
    else
        echo "Warning: Could not find boot entry to update"
    fi
else
    echo "Warning: Could not find deploy directory for fstab"
fi

# Finalize filesystem (fstrim + remount ro)
echo "Finalizing filesystem..."
sudo fstrim -v "${MOUNT_POINT}" 2>/dev/null || true

# Sync and unmount
echo "Syncing and unmounting..."
sync
sudo umount -R "${MOUNT_POINT}"
sudo losetup -d "${LOOP_DEV}"
trap - EXIT

echo ""
echo "=== Build complete ==="
echo "Bootable image: ${IMAGE_FILE}"
echo ""
echo "To test with QEMU:"
echo "  qemu-system-x86_64 -enable-kvm -m 4G -drive file=${IMAGE_FILE},format=raw"
